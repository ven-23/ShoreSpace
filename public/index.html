<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ShoreSpace</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap"
    rel="stylesheet" />
  <link rel="icon" type="image/svg+xml" href="assets/favicon.svg" />
  <script src="https://unpkg.com/@phosphor-icons/web"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <style>
    :root {
      /* --- Color Palette: Void & Neon --- */
      --bg-body: #030712;
      --bg-panel: rgba(17, 24, 39, 0.6);
      --bg-glass: rgba(31, 41, 55, 0.4);
      --bg-glass-hover: rgba(55, 65, 81, 0.5);

      --primary: #06b6d4;
      /* Cyan 500 */
      --primary-dim: rgba(6, 182, 212, 0.1);
      --primary-glow: rgba(6, 182, 212, 0.5);

      --accent: #6366f1;
      /* Indigo 500 */

      --success: #10b981;
      /* Emerald 500 */
      --success-dim: rgba(16, 185, 129, 0.1);
      --success-glow: rgba(16, 185, 129, 0.4);

      --danger: #ef4444;
      /* Red 500 */
      --danger-dim: rgba(239, 68, 68, 0.1);

      --warning: #f59e0b;
      /* Amber 500 */

      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --text-dim: #4b5563;

      --border: rgba(255, 255, 255, 0.08);
      --border-highlight: rgba(255, 255, 255, 0.15);

      --ease-out: cubic-bezier(0.215, 0.61, 0.355, 1);
    }

    * {
      box-sizing: border-box;
      scrollbar-width: thin;
      scrollbar-color: var(--bg-glass-hover) transparent;
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-glass-hover);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    body {
      font-family: "Inter", sans-serif;
      background-color: var(--bg-body);
      /* Cyber grid background */
      background-image: linear-gradient(var(--bg-body) 0%, transparent 100%),
        radial-gradient(circle at 50% 0%, #1e293b 0%, var(--bg-body) 60%),
        linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
      background-size: 100% 100%, 100% 100%, 40px 40px, 40px 40px;
      background-position: center top;
      color: var(--text-main);
      margin: 0;
      height: 100vh;
      overflow: hidden;
      display: flex;
    }

    /* --- Glass Component Utility --- */
    .glass-panel {
      background: var(--bg-panel);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--border);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    /* --- Sidebar --- */
    .sidebar {
      width: 260px;
      height: 100%;
      background: rgba(10, 10, 15, 0.8);
      backdrop-filter: blur(20px);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      padding: 24px;
      gap: 24px;
      z-index: 100;
      position: relative;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--text-main);
      letter-spacing: -0.02em;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--border);
    }

    .brand-icon-box {
      width: 36px;
      height: 36px;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      box-shadow: 0 0 15px var(--primary-glow);
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: rgba(16, 185, 129, 0.05);
      border: 1px solid rgba(16, 185, 129, 0.2);
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--success);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .pulse-dot {
      width: 8px;
      height: 8px;
      background: var(--success);
      border-radius: 50%;
      box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
      animation: pulse-green 2s infinite;
    }

    /* --- Sidebar Sections --- */
    .control-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .section-title {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-dim);
      font-weight: 700;
      margin-bottom: 4px;
    }

    /* --- Buttons --- */
    button {
      font-family: inherit;
      cursor: pointer;
      border: none;
      outline: none;
      transition: all 0.2s var(--ease-out);
    }

    .nav-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      border-radius: 8px;
      background: transparent;
      color: var(--text-muted);
      font-size: 0.85rem;
      font-weight: 500;
      border: 1px solid transparent;
      text-align: left;
      width: 100%;
      text-decoration: none;
      /* For A tags */
    }

    .nav-btn:hover {
      background: var(--bg-glass);
      color: var(--text-main);
      border-color: var(--border);
    }

    .nav-btn i {
      font-size: 1.1rem;
    }

    /* Primary Action Button (Add Slot) */
    .btn-primary {
      background: linear-gradient(135deg, var(--primary), #0ea5e9);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 12px rgba(6, 182, 212, 0.25);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(6, 182, 212, 0.4);
    }

    /* Active/Drawing State */
    .nav-btn.active-mode {
      background: var(--warning);
      color: #000;
      font-weight: 700;
      box-shadow: 0 0 15px rgba(245, 158, 11, 0.4);
      animation: pulse-border 1.5s infinite;
    }

    /* --- Main Layout --- */
    .app-container {
      flex: 1;
      padding: 20px;
      display: grid;
      grid-template-columns: 2.5fr 1.2fr;
      grid-template-rows: 1fr auto;
      gap: 20px;
      height: 100vh;
      overflow: hidden;
    }

    /* --- Feed Section (Top Left) --- */
    .feed-container {
      grid-column: 1 / 2;
      grid-row: 1 / 2;
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-height: 0;
      /* Fix flex overflow */
    }

    .video-wrapper {
      flex: 1;
      position: relative;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
      /* Corner decorations */
      --corner-size: 15px;
      --corner-color: var(--primary);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Futuristic Corners for Video */
    .video-wrapper::before,
    .video-wrapper::after {
      content: "";
      position: absolute;
      width: var(--corner-size);
      height: var(--corner-size);
      border: 2px solid var(--corner-color);
      transition: all 0.3s ease;
      z-index: 10;
      pointer-events: none;
    }

    .video-wrapper::before {
      top: 10px;
      left: 10px;
      border-right: none;
      border-bottom: none;
    }

    .video-wrapper::after {
      bottom: 10px;
      right: 10px;
      border-left: none;
      border-top: none;
    }

    video,
    canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
      /* Changed to contain so we see full video frame even if uploaded */
      display: block;
    }

    /* Only hide video if we want canvas overlay, but we layer them */
    video {
      position: absolute;
      top: 0;
      left: 0;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 5;
      pointer-events: all;
      /* Allow drawing on canvas */
    }

    .live-badge {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      padding: 4px 10px;
      border-radius: 4px;
      color: var(--danger);
      font-size: 0.7rem;
      font-weight: 800;
      letter-spacing: 0.1em;
      border: 1px solid rgba(239, 68, 68, 0.3);
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 20;
      pointer-events: none;
    }

    .live-dot {
      width: 6px;
      height: 6px;
      background: var(--danger);
      border-radius: 50%;
      animation: pulse-red 1.5s infinite;
    }

    .source-badge {
      background: rgba(0, 0, 0, 0.6);
      color: var(--primary);
      border-color: var(--primary-glow);
    }

    .source-dot {
      background: var(--primary);
      animation: none;
    }

    /* --- Stats Deck (Bottom Left) --- */
    .stats-deck {
      grid-column: 1 / 2;
      grid-row: 2 / 3;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      height: 120px;
    }

    .stat-card {
      background: linear-gradient(180deg,
          rgba(31, 41, 55, 0.4) 0%,
          rgba(17, 24, 39, 0.6) 100%);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 20px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      transition: transform 0.2s;
    }

    .stat-card:hover {
      transform: translateY(-2px);
      border-color: var(--border-highlight);
    }

    .stat-header {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-muted);
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .stat-value {
      font-family: "JetBrains Mono", monospace;
      font-size: 2.5rem;
      font-weight: 700;
      line-height: 1;
      color: var(--text-main);
    }

    /* Color coding stats */
    .stat-card.primary .stat-value {
      color: var(--primary);
      text-shadow: 0 0 20px var(--primary-dim);
    }

    .stat-card.success .stat-value {
      color: var(--success);
      text-shadow: 0 0 20px var(--success-dim);
    }

    .stat-card.danger .stat-value {
      color: var(--danger);
      text-shadow: 0 0 20px var(--danger-dim);
    }

    /* --- Data Panel (Right) --- */
    .data-panel {
      grid-column: 2 / 3;
      grid-row: 1 / 3;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Tabs */
    .tabs-nav {
      display: flex;
      padding: 6px;
      gap: 6px;
      background: rgba(0, 0, 0, 0.2);
      border-bottom: 1px solid var(--border);
    }

    .tab-btn {
      flex: 1;
      padding: 10px;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-muted);
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: var(--text-main);
      background: rgba(255, 255, 255, 0.03);
    }

    .tab-btn.active {
      background: var(--bg-glass-hover);
      color: var(--primary);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .tab-content {
      flex: 1;
      overflow: hidden;
      display: none;
      position: relative;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
      animation: fadeIn 0.3s ease;
    }

    /* Tables */
    .table-container {
      flex: 1;
      overflow-y: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    thead {
      position: sticky;
      top: 0;
      background: #0f1523;
      /* Solid color to cover scroll */
      z-index: 10;
      box-shadow: 0 1px 0 var(--border);
    }

    th {
      text-align: left;
      padding: 14px 16px;
      color: var(--text-muted);
      font-weight: 600;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    td {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      color: var(--text-main);
      transition: background 0.2s;
    }

    tr:hover td {
      background: rgba(255, 255, 255, 0.02);
    }

    .font-mono {
      font-family: "JetBrains Mono", monospace;
    }

    /* Revenue Header inside Tab */
    .revenue-summary {
      padding: 20px;
      background: linear-gradient(90deg,
          rgba(16, 185, 129, 0.05) 0%,
          transparent 100%);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .revenue-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--success);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .revenue-amount {
      font-family: "JetBrains Mono", monospace;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-main);
      text-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
    }

    /* Action Buttons in Table */
    .action-cell {
      display: flex;
      gap: 8px;
    }

    .icon-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-muted);
      transition: all 0.2s;
    }

    .icon-btn:hover {
      background: var(--text-main);
      color: var(--bg-body);
    }

    .icon-btn.delete:hover {
      background: var(--danger);
      color: #fff;
    }

    /* --- Toast/Floating --- */
    .home-float {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-muted);
      font-size: 0.8rem;
      text-decoration: none;
      opacity: 0.6;
      transition: all 0.2s;
      z-index: 999;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 8px;
    }

    .home-float:hover {
      opacity: 1;
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }

    /* --- Modal Styles (THEMED) --- */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 2000;
      /* Above sidebar */
      justify-content: center;
      align-items: center;
    }

    .modal-box {
      background: rgba(17, 24, 39, 0.95);
      border: 1px solid var(--border);
      padding: 30px;
      border-radius: 16px;
      width: 90%;
      max-width: 380px;
      text-align: center;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
      animation: popIn 0.3s var(--ease-out);
    }

    .modal-icon {
      width: 64px;
      height: 64px;
      background: rgba(239, 68, 68, 0.15);
      color: var(--danger);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      margin: 0 auto 20px auto;
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.2);
    }

    /* Dynamic Icon Colors */
    .modal-icon.warning {
      color: var(--warning);
      background: rgba(245, 158, 11, 0.15);
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.2);
    }

    .modal-icon.info {
      color: var(--primary);
      background: rgba(6, 182, 212, 0.15);
      box-shadow: 0 0 20px rgba(6, 182, 212, 0.2);
    }

    .modal-box h3 {
      margin: 0 0 12px 0;
      color: var(--text-main);
      font-size: 1.2rem;
      font-weight: 700;
    }

    .modal-box p {
      margin: 0 0 25px 0;
      color: var(--text-muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
    }

    .modal-btn {
      flex: 1;
      padding: 12px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .modal-btn.cancel {
      background: transparent;
      border-color: var(--border);
      color: var(--text-muted);
    }

    .modal-btn.cancel:hover {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-main);
    }

    .modal-btn.confirm {
      background: var(--danger);
      color: white;
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
    }

    .modal-btn.confirm:hover {
      background: #dc2626;
      transform: translateY(-1px);
    }

    /* Toast Notification */
    .toast-container {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .toast {
      background: rgba(17, 24, 39, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
      color: var(--text-main);
      padding: 12px 24px;
      border-radius: 50px;
      font-size: 0.9rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .toast.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .toast.success {
      border-color: var(--success);
      color: var(--success);
    }

    .toast.error {
      border-color: var(--danger);
      color: var(--danger);
    }

    .toast.info {
      border-color: var(--primary);
      color: var(--primary);
    }

    /* --- Ticket Modal Styles --- */
    .ticket-container {
      background: var(--bg-panel);
      width: 100%;
      max-width: 380px;
      border-radius: 16px;
      border: 1px solid var(--border);
      overflow: hidden;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.7);
      color: var(--text-main);
    }

    .ticket-top {
      height: 8px;
      background: var(--primary);
      width: 100%;
      box-shadow: 0 0 15px var(--primary-glow);
    }

    .ticket-content {
      padding: 30px;
      text-align: center;
    }

    .ticket-brand {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text-main);
      margin-bottom: 5px;
    }

    .ticket-label {
      color: var(--text-muted);
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 20px;
    }

    .ticket-divider {
      border-bottom: 2px dashed var(--border);
      margin: 20px 0;
      position: relative;
    }

    .ticket-price-section {
      margin: 20px 0;
    }

    .ticket-price-label {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .ticket-price-value {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--success);
      font-family: "JetBrains Mono", monospace;
      text-shadow: 0 0 20px var(--success-dim);
    }

    .ticket-info-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      text-align: left;
      margin-bottom: 25px;
    }

    .ticket-info-item label {
      display: block;
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 4px;
      text-transform: uppercase;
    }

    .ticket-info-item span {
      font-weight: 600;
      font-size: 1rem;
      color: var(--text-main);
    }

    .qr-wrapper {
      background: white;
      padding: 10px;
      border-radius: 8px;
      display: inline-block;
      margin-bottom: 20px;
    }

    .ticket-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .ticket-btn {
      flex: 1;
      padding: 12px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .ticket-btn.print {
      background: transparent;
      border-color: var(--border);
      color: var(--text-muted);
    }

    .ticket-btn.print:hover {
      color: var(--text-main);
      border-color: var(--text-main);
    }

    .ticket-btn.close {
      background: var(--danger);
      color: white;
    }

    .ticket-btn.close:hover {
      background: #dc2626;
    }

    /* Animations */
    @keyframes popIn {
      from {
        transform: scale(0.9);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes pulse-green {
      0% {
        box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4);
      }

      70% {
        box-shadow: 0 0 0 6px rgba(16, 185, 129, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
      }
    }

    @keyframes pulse-red {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    @keyframes pulse-border {
      0% {
        border-color: var(--warning);
      }

      50% {
        border-color: transparent;
      }

      100% {
        border-color: var(--warning);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .app-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr;
        height: auto;
        overflow-y: auto;
      }

      .sidebar {
        width: 80px;
        align-items: center;
        padding: 15px;
      }

      .brand span,
      .nav-btn span,
      .section-title,
      .status-indicator span {
        display: none;
      }

      .nav-btn {
        justify-content: center;
        padding: 12px;
      }

      .stats-deck {
        height: auto;
      }

      /* Keep home-float visible but just icon */
      .home-float span {
        display: none;
      }
    }
  </style>
</head>

<body>
  <!-- Sidebar -->
  <div class="sidebar">
    <div class="brand">
      <div class="brand-icon-box">
        <i class="ph-bold ph-car-profile"></i>
      </div>
      <span>Shore<span style="color: var(--primary)">Space</span></span>
    </div>

    <div class="status-indicator" id="system-status">
      <div class="pulse-dot"></div>
      <span id="status-text">Live Cam</span>
    </div>

    <div class="control-section">
      <div class="section-title">Mapping Tools</div>
      <button id="add-slot-btn" class="nav-btn btn-primary" onclick="toggleDrawingMode()" title="Define new slot">
        <i class="ph-bold ph-plus"></i>
        <span>Add Slot</span>
      </button>
      <button class="nav-btn" onclick="resetMap()" title="Clear Map">
        <i class="ph-bold ph-eraser"></i>
        <span>Clear Canvas</span>
      </button>
    </div>

    <!-- NEW SECTION: Video Source -->
    <div class="control-section">
      <div class="section-title">Video Source</div>
      <!-- Hidden Inputs -->
      <input type="file" id="video-loader" style="display: none" accept="video/*" onchange="handleVideoUpload(this)" />

      <button class="nav-btn" onclick="triggerLoadVideo()">
        <i class="ph-bold ph-film-strip"></i>
        <span>Upload Video</span>
      </button>
      <button class="nav-btn" onclick="startCamera()" id="btn-webcam">
        <i class="ph-bold ph-video-camera"></i>
        <span>Live Webcam</span>
      </button>

      <!-- Play Button (Visible only when video uploaded) -->
      <button id="btn-video-control" class="nav-btn" onclick="toggleVideoPlayback()" style="
            display: none;
            color: var(--primary);
            border-color: var(--primary-dim);
          ">
        <i class="ph-bold ph-play"></i>
        <span>Start Analysis</span>
      </button>
    </div>

    <div class="control-section">
      <div class="section-title">Configuration</div>
      <!-- Hidden File Input for Layout -->
      <input type="file" id="layout-loader" style="display: none" accept=".json" onchange="importLayoutFile(this)" />

      <button class="nav-btn" onclick="exportLayout()">
        <i class="ph-bold ph-download-simple"></i>
        <span>Export Layout</span>
      </button>
      <button class="nav-btn" onclick="triggerLoadLayout()">
        <i class="ph-bold ph-upload-simple"></i>
        <span>Import Layout</span>
      </button>
    </div>

    <div class="control-section">
      <div class="section-title">System</div>
      <button class="nav-btn" onclick="captureBackground()">
        <i class="ph-bold ph-aperture"></i>
        <span>Calibrate Cam</span>
      </button>
      <button class="nav-btn" onclick="openGraphs()">
        <i class="ph-bold ph-chart-line-up"></i>
        <span>Analytics</span>
      </button>
      <a href="settings.html" class="nav-btn">
        <i class="ph-bold ph-gear"></i>
        <span>Settings</span>
      </a>
      <button class="nav-btn" onclick="openHelp()">
        <i class="ph-bold ph-question"></i>
        <span>Help</span>
      </button>
    </div>


  </div>

  <!-- Main Dashboard -->
  <div class="app-container">
    <!-- Video Feed -->
    <div class="feed-container">
      <div class="video-wrapper">
        <div class="live-badge" id="live-badge">
          <div class="live-dot" id="live-dot"></div>
          <span id="live-text">REC</span>
        </div>
        <!-- Video element reused for both webcam and file -->
        <video id="webcam" autoplay playsinline width="640" height="480"></video>
        <canvas id="overlay"></canvas>
      </div>
    </div>

    <!-- Statistics Deck -->
    <div class="stats-deck">
      <div class="stat-card primary">
        <div class="stat-header">
          <i class="ph-bold ph-squares-four"></i> Capacity
        </div>
        <div class="stat-value" id="total-count">0</div>
      </div>
      <div class="stat-card success">
        <div class="stat-header">
          <i class="ph-bold ph-check-circle"></i> Available
        </div>
        <div class="stat-value" id="free-count">0</div>
      </div>
      <div class="stat-card danger">
        <div class="stat-header"><i class="ph-bold ph-car"></i> Occupied</div>
        <div class="stat-value" id="occupied-count">0</div>
      </div>
    </div>

    <!-- Data/Tabs Panel -->
    <div class="data-panel glass-panel">
      <div class="tabs-nav">
        <button class="tab-btn active" onclick="switchTab('history')">
          <i class="ph-bold ph-clock-counter-clockwise"></i> Live Log
        </button>
        <button class="tab-btn" onclick="switchTab('revenue')">
          <i class="ph-bold ph-currency-circle-dollar"></i> Revenue
        </button>
      </div>

      <div id="history" class="tab-content active">
        <div class="table-container">
          <table>
            <thead>
              <tr>
                <th>Slot ID</th>
                <th>Entry</th>
                <th>Exit</th>
                <th>Duration</th>
                <th>Fee</th>
                <th style="text-align: right">Action</th>
              </tr>
            </thead>
            <tbody id="history-body">
              <!-- JS populates this -->
            </tbody>
          </table>
        </div>
      </div>

      <div id="revenue" class="tab-content">
        <div class="revenue-summary">
          <span class="revenue-label">Total Generated</span>
          <span class="revenue-amount">₱<span id="total-revenue">0.00</span></span>
        </div>
        <div class="table-container">
          <table>
            <thead>
              <tr>
                <th>Trans. ID</th>
                <th>Slot Ref</th>
                <th>Amount</th>
              </tr>
            </thead>
            <tbody id="revenue-body">
              <!-- JS populates this -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden Modal: Confirm -->
  <div id="confirm-modal" class="modal-overlay">
    <div class="modal-box glass-panel">
      <div class="modal-icon">
        <i class="ph-bold ph-trash"></i>
      </div>
      <h3 id="modal-title">Confirm Action</h3>
      <p id="modal-msg">Are you sure you want to proceed?</p>
      <div class="modal-actions">
        <button class="modal-btn cancel" onclick="closeModal(false)">
          Cancel
        </button>
        <button class="modal-btn confirm" onclick="closeModal(true)">
          Confirm
        </button>
      </div>
    </div>
  </div>

  <!-- Hidden Modal: Ticket Receipt -->
  <div id="ticket-modal" class="modal-overlay">
    <div class="ticket-container">
      <div class="ticket-top"></div>
      <div class="ticket-content">
        <div class="ticket-brand">
          <i class="ph-fill ph-car-profile" style="color: var(--primary)"></i>
          ShoreSpace
        </div>
        <div class="ticket-label">Official Receipt</div>

        <div class="ticket-price-section">
          <div class="ticket-price-value">
            ₱<span id="ticket-payment">0.00</span>
          </div>
          <div class="ticket-price-label">Total Amount Paid</div>
        </div>

        <div class="ticket-divider"></div>

        <div class="ticket-info-grid">
          <div class="ticket-info-item">
            <label>Slot Number</label>
            <span id="ticket-slot">-</span>
          </div>
          <div class="ticket-info-item">
            <label>Duration</label>
            <span id="ticket-duration">00:00:00</span>
          </div>
          <div class="ticket-info-item">
            <label>Entry Time</label>
            <span id="ticket-entry">-</span>
          </div>
          <div class="ticket-info-item">
            <label>Exit Time</label>
            <span id="ticket-exit">-</span>
          </div>
        </div>

        <div class="qr-wrapper">
          <div id="qrcode"></div>
        </div>

        <div class="ticket-actions">
          <button class="ticket-btn print" onclick="window.print()">
            <i class="ph-bold ph-printer"></i> Print
          </button>
          <button class="ticket-btn close" onclick="closeTicketModal()">
            Close
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Javascript Logic -->
  <script>
    // --- Config Loader ---
    let appConfig = {
      baseRate: 35, // Initial Fee
      incrementAmount: 5, // Add 5 pesos...
      baseDuration: 10, // ...after first 10 seconds...
      incrementInterval: 5, // ...every 5 seconds
    };

    // --- Custom Modal Logic ---
    let modalResolve = null;

    function showConfirmModal(
      message,
      title = "Confirm Action",
      iconClass = "ph-warning-circle"
    ) {
      const modal = document.getElementById("confirm-modal");
      const msgEl = document.getElementById("modal-msg");
      const titleEl = document.getElementById("modal-title");
      const iconEl = document.querySelector("#confirm-modal .modal-icon i");

      msgEl.innerText = message;
      titleEl.innerText = title;

      const iconContainer = document.querySelector(
        "#confirm-modal .modal-icon"
      );
      iconContainer.className = "modal-icon";

      if (iconClass.includes("trash") || iconClass.includes("sign-out"))
        iconContainer.classList.add("danger");
      else if (iconClass.includes("warning"))
        iconContainer.classList.add("warning");
      else iconContainer.classList.add("info");

      iconEl.className = `ph-bold ${iconClass}`;

      modal.style.display = "flex";

      return new Promise((resolve) => {
        modalResolve = resolve;
      });
    }

    function closeModal(isConfirmed) {
      document.getElementById("confirm-modal").style.display = "none";
      if (modalResolve) {
        modalResolve(isConfirmed);
        modalResolve = null;
      }
    }



    // --- Ticket Modal Logic ---
    function openSpecificTicket(ticketData) {
      document.getElementById("ticket-slot").innerText =
        ticketData.slot || "-";
      document.getElementById("ticket-entry").innerText =
        ticketData.entry || "-";
      document.getElementById("ticket-exit").innerText =
        ticketData.exit || "-";
      document.getElementById("ticket-duration").innerText =
        ticketData.duration || "00:00:00";

      const payVal = parseFloat(ticketData.payment || 0).toFixed(2);
      document.getElementById("ticket-payment").innerText = payVal;

      const qrContainer = document.getElementById("qrcode");
      qrContainer.innerHTML = "";
      new QRCode(qrContainer, {
        text: JSON.stringify(ticketData),
        width: 128,
        height: 128,
        colorDark: "#000000",
        colorLight: "#ffffff",
        correctLevel: QRCode.CorrectLevel.M,
      });

      document.getElementById("ticket-modal").style.display = "flex";
    }

    function closeTicketModal() {
      document.getElementById("ticket-modal").style.display = "none";
    }

    // --- Toast System ---
    function showToast(message, type = "info") {
      let container = document.querySelector(".toast-container");
      if (!container) {
        container = document.createElement("div");
        container.className = "toast-container";
        document.body.appendChild(container);
      }

      const toast = document.createElement("div");
      toast.className = `toast ${type}`;

      let icon = "ph-info";
      if (type === "success") icon = "ph-check-circle";
      if (type === "error") icon = "ph-warning-circle";

      toast.innerHTML = `<i class="ph-bold ${icon}"></i> <span>${message}</span>`;

      container.appendChild(toast);

      requestAnimationFrame(() => {
        toast.classList.add("visible");
      });

      setTimeout(() => {
        toast.classList.remove("visible");
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    function openHelp() {
      window.location.href = "help.html";
    }

    // --- UI Logic ---
    function switchTab(tabId) {
      document
        .querySelectorAll(".tab-btn")
        .forEach((btn) => btn.classList.remove("active"));
      document
        .querySelectorAll(".tab-content")
        .forEach((content) => content.classList.remove("active"));

      document
        .querySelector(`button[onclick="switchTab('${tabId}')"]`)
        .classList.add("active");
      document.getElementById(tabId).classList.add("active");
    }

    // --- ParkSense Logic ---
    const video = document.getElementById("webcam");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const historyBody = document.getElementById("history-body");
    const revenueBody = document.getElementById("revenue-body");
    const totalRevenueEl = document.getElementById("total-revenue");

    const PIXEL_DIFF_THRESHOLD = 30;
    const COVERAGE_THRESHOLD = 0.15;
    let backgroundPixels = null;
    let isStreamReady = false;
    let inputMode = "webcam"; // 'webcam' or 'video'
    let revenueTotal = 0;
    let transactionCount = 0;

    let slots = [];
    let isDrawing = false;
    let tempPoints = [];

    let draggingSlot = null;
    let dragStartPoint = null;
    let hoveredSlot = null;

    let latestParking = {};
    let historyData = [];
    let revenueData = [];

    // --- VIDEO & WEBCAM MANAGEMENT ---

    async function startCamera() {
      inputMode = "webcam";
      updateStatusBadge(true);
      document.getElementById("btn-video-control").style.display = "none";
      video.controls = false;

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 640, height: 480 },
        });
        video.srcObject = stream;
        video.src = "";
        video.play();

        video.onloadedmetadata = () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          isStreamReady = true;
          addLog("Camera connected. Load Layout or Add Slots.");
          requestAnimationFrame(processFrame);
        };
      } catch (err) {
        addLog("Error accessing camera: " + err.message);
        showToast("Camera Access Failed", "error");
      }
    }

    function triggerLoadVideo() {
      document.getElementById("video-loader").click();
    }

    function handleVideoUpload(input) {
      const file = input.files[0];
      if (!file) return;

      inputMode = "video";
      updateStatusBadge(false);

      // Show the play button
      const playBtn = document.getElementById("btn-video-control");
      playBtn.style.display = "flex";
      playBtn.innerHTML = `<i class="ph-bold ph-play"></i> <span>Start Analysis</span>`;

      // Stop existing webcam streams
      if (video.srcObject) {
        video.srcObject.getTracks().forEach((track) => track.stop());
        video.srcObject = null;
      }

      const fileURL = URL.createObjectURL(file);
      video.src = fileURL;
      video.load();

      // IMPORTANT: Pause initially so user can place slots
      video.pause();

      // Enable controls so user can scrub to empty frame
      video.controls = true;

      video.onloadeddata = () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        isStreamReady = true;
        backgroundPixels = null; // Reset background on new video

        showToast("Video Loaded. Paused for Setup.", "info");
        addLog("Video loaded. Please Calibrate on an empty frame.");

        // Start the loop, but it will only process the current frame
        requestAnimationFrame(processFrame);
      };

      input.value = "";
    }

    function toggleVideoPlayback() {
      const btn = document.getElementById("btn-video-control");
      if (video.paused) {
        video.play();
        btn.innerHTML = `<i class="ph-bold ph-pause"></i> <span>Pause Analysis</span>`;
      } else {
        video.pause();
        btn.innerHTML = `<i class="ph-bold ph-play"></i> <span>Resume Analysis</span>`;
      }
    }

    function updateStatusBadge(isLive) {
      const badge = document.getElementById("live-badge");
      const dot = document.getElementById("live-dot");
      const text = document.getElementById("live-text");
      const statusText = document.getElementById("status-text");

      if (isLive) {
        badge.className = "live-badge";
        dot.className = "live-dot";
        text.innerText = "REC";
        statusText.innerText = "Live Cam";
      } else {
        badge.className = "live-badge source-badge";
        dot.className = "live-dot source-dot";
        text.innerText = "VIDEO";
        statusText.innerText = "Video File";
      }
    }

    // --- DETECTION & PROCESSING ---

    async function captureBackground() {
      if (!isStreamReady) return;

      const message =
        inputMode === "video"
          ? "Ensure the video is paused on an EMPTY frame (no cars in slots). Calibrate now?"
          : "Ensure all parking slots are completely EMPTY. Continue?";

      const confirmed = await showConfirmModal(
        message,
        "Calibrate System",
        "ph-aperture"
      );

      if (confirmed) {
        showToast("Calibrating...", "info");

        setTimeout(() => {
          ctx.save();
          if (inputMode === "webcam") {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
          }

          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          ctx.restore();

          backgroundPixels = ctx.getImageData(
            0,
            0,
            canvas.width,
            canvas.height
          ).data;

          addLog("Background calibrated.");
          showToast("Calibration Successful. You may play video.", "success");
        }, 500);
      }
    }

    function processFrame() {
      if (isStreamReady) {
        // Reset button if video ends
        if (inputMode === "video" && video.ended) {
          const btn = document.getElementById("btn-video-control");
          btn.innerHTML = `<i class="ph-bold ph-arrow-counter-clockwise"></i> <span>Replay</span>`;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        if (inputMode === "webcam") {
          ctx.translate(canvas.width, 0);
          ctx.scale(-1, 1);
        }
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        ctx.restore();

        if (backgroundPixels && !video.ended) detectOccupancy();

        drawOverlays();
        updateStats();
      }

      requestAnimationFrame(processFrame);
    }

    function detectOccupancy() {
      if (slots.length === 0) return;

      const currentPixels = ctx.getImageData(
        0,
        0,
        canvas.width,
        canvas.height
      ).data;

      slots.forEach((slot) => {
        let significantDiffPixels = 0;

        const xs = slot.points.map((p) => p.x);
        const ys = slot.points.map((p) => p.y);
        const minX = Math.floor(Math.min(...xs));
        const maxX = Math.ceil(Math.max(...xs));
        const minY = Math.floor(Math.min(...ys));
        const maxY = Math.ceil(Math.max(...ys));

        const width = maxX - minX;
        const height = maxY - minY;
        const totalArea = width * height;

        for (let y = minY; y < maxY; y += 4) {
          for (let x = minX; x < maxX; x += 4) {
            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height)
              continue;

            const i = (y * canvas.width + x) * 4;
            const rDiff = Math.abs(currentPixels[i] - backgroundPixels[i]);
            const gDiff = Math.abs(
              currentPixels[i + 1] - backgroundPixels[i + 1]
            );
            const bDiff = Math.abs(
              currentPixels[i + 2] - backgroundPixels[i + 2]
            );

            if (rDiff + gDiff + bDiff > PIXEL_DIFF_THRESHOLD * 3) {
              significantDiffPixels++;
            }
          }
        }

        const coverage = significantDiffPixels / (totalArea / 16);
        const wasOccupied = slot.occupied; // Visual State

        const isOccupiedNow = coverage > COVERAGE_THRESHOLD;
        const isEmptyNow = coverage < COVERAGE_THRESHOLD * 0.8;

        if (isOccupiedNow) {
          // Visual: Red immediately
          slot.occupied = true;

          // Timer Logic for Logging
          if (!slot.tempEntryTime) {
            slot.tempEntryTime = Date.now(); // Start tracking duration
          } else {
            const elapsed = Date.now() - slot.tempEntryTime;
            // If 5 seconds passed and we haven't logged yet
            if (elapsed >= 10000 && !slot.entryTime) {
              slot.entryTime = new Date(); // Official Session Start
              addLog(`ENTRY: Slot ${slot.label}`);

              // --- LIVE LOG UPDATE (Entry) ---
              // Add row immediately as "Active"
              addHistoryRow(
                slot.label,
                slot.entryTime,
                null, // No exit time yet
                "Active",
                appConfig.baseRate,
                null
              );
            }
          }
        } else if (isEmptyNow) {
          // Visual: Green immediately
          slot.occupied = false;

          // Log Logic: Did we have a valid session?
          if (slot.entryTime) {
            const exitTime = new Date();
            const durationSec = Math.floor(
              (exitTime - slot.entryTime) / 1000
            );

            // Pricing Logic
            // Pricing Logic
            const paymentStr = calculateFee(durationSec);
            const paymentVal = parseFloat(paymentStr);

            addLog(`EXIT: Slot ${slot.label} | ₱${paymentStr}`);

            // --- START LOCALSTORAGE SAVE LOGIC ---
            const payload = {
              id: Date.now(), // Simple unique ID
              slot: slot.label,
              entry_time: slot.entryTime.toISOString(),
              exit_time: exitTime.toISOString(),
              duration_sec: durationSec,
              payment: paymentVal,
            };

            // Get existing history or initialize empty array
            const existingHistory = JSON.parse(localStorage.getItem('parkingHistory') || '[]');
            existingHistory.push(payload);
            localStorage.setItem('parkingHistory', JSON.stringify(existingHistory));

            showToast("Saved to Local Storage", "success");
            // --- END LOCALSTORAGE SAVE LOGIC ---

            addHistoryRow(
              slot.label,
              slot.entryTime,
              exitTime,
              formatDuration(durationSec),
              paymentStr
            );
            addRevenueRow(
              slot.label,
              paymentStr,
              slot.entryTime.toISOString()
            );

            slot.entryTime = null; // End session
          }

          // Reset temporary timer since it's empty
          slot.tempEntryTime = null;
        }
      });
    }

    // --- MAPPING TOOLS (DRAWING) ---

    // Update Coordinate Logic to handle video aspect ratios properly (object-fit: contain)
    function getCanvasCoordinates(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      const rectWidth = rect.width;
      const rectHeight = rect.height;

      // Calculate aspect ratios
      const canvasRatio = canvasWidth / canvasHeight;
      const rectRatio = rectWidth / rectHeight;

      let scale;
      let offsetX = 0;
      let offsetY = 0;

      if (rectRatio > canvasRatio) {
        // Rect is wider than canvas -> Canvas fits height
        scale = rectHeight / canvasHeight;
        offsetX = (rectWidth - canvasWidth * scale) / 2;
      } else {
        // Rect is taller/same -> Canvas fits width
        scale = rectWidth / canvasWidth;
        offsetY = (rectHeight - canvasHeight * scale) / 2;
      }

      const finalX = (x - offsetX) / scale;
      const finalY = (y - offsetY) / scale;

      return { x: finalX, y: finalY };
    }

    function isPointInPolygon(p, polygon) {
      let isInside = false;
      let minX = polygon[0].x,
        maxX = polygon[0].x;
      let minY = polygon[0].y,
        maxY = polygon[0].y;
      for (let n = 1; n < polygon.length; n++) {
        const q = polygon[n];
        minX = Math.min(q.x, minX);
        maxX = Math.max(q.x, maxX);
        minY = Math.min(q.y, minY);
        maxY = Math.max(q.y, maxY);
      }

      if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) {
        return false;
      }

      let i = 0,
        j = polygon.length - 1;
      for (i, j; i < polygon.length; j = i++) {
        if (
          polygon[i].y > p.y != polygon[j].y > p.y &&
          p.x <
          ((polygon[j].x - polygon[i].x) * (p.y - polygon[i].y)) /
          (polygon[j].y - polygon[i].y) +
          polygon[i].x
        ) {
          isInside = !isInside;
        }
      }
      return isInside;
    }

    // Mouse Events
    canvas.addEventListener("mousedown", (e) => {
      const pos = getCanvasCoordinates(e);

      if (isDrawing) {
        tempPoints.push(pos);
        if (tempPoints.length === 4) {
          finalizeSlot();
        }
      } else {
        for (let i = slots.length - 1; i >= 0; i--) {
          if (isPointInPolygon(pos, slots[i].points)) {
            draggingSlot = slots[i];
            dragStartPoint = pos;
            break;
          }
        }
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      const pos = getCanvasCoordinates(e);

      if (draggingSlot && dragStartPoint) {
        const dx = pos.x - dragStartPoint.x;
        const dy = pos.y - dragStartPoint.y;
        draggingSlot.points.forEach((p) => {
          p.x += dx;
          p.y += dy;
        });
        dragStartPoint = pos;
        return;
      }

      if (!isDrawing) {
        let found = null;
        for (let i = slots.length - 1; i >= 0; i--) {
          if (isPointInPolygon(pos, slots[i].points)) {
            found = slots[i];
            break;
          }
        }
        hoveredSlot = found;
        canvas.style.cursor = found ? "move" : "default";
      }
    });

    canvas.addEventListener("mouseup", () => {
      if (draggingSlot) {
        draggingSlot = null;
        dragStartPoint = null;
        saveLayout();
      }
    });

    canvas.addEventListener("contextmenu", async (e) => {
      e.preventDefault();
      if (isDrawing) return;

      const pos = getCanvasCoordinates(e);
      const clickedSlotIndex = slots.findIndex((s) =>
        isPointInPolygon(pos, s.points)
      );

      if (clickedSlotIndex !== -1) {
        const slotLabel = slots[clickedSlotIndex].label;
        const confirmed = await showConfirmModal(
          `Delete Slot ${slotLabel}?`,
          "Delete Slot",
          "ph-trash"
        );
        if (confirmed) {
          slots.splice(clickedSlotIndex, 1);
          saveLayout();
          updateStats();
          showToast(`Deleted Slot ${slotLabel}`, "success");
        }
      }
    });

    function toggleDrawingMode() {
      isDrawing = !isDrawing;
      const btn = document.getElementById("add-slot-btn");
      if (isDrawing) {
        btn.classList.add("active-mode");
        btn.innerHTML = `<i class="ph-bold ph-pencil-simple"></i> <span>Click 4 Points</span>`;
        tempPoints = [];
        canvas.style.cursor = "crosshair";
      } else {
        btn.classList.remove("active-mode");
        btn.innerHTML = `<i class="ph-bold ph-plus"></i> <span>Add Slot</span>`;
        tempPoints = [];
        canvas.style.cursor = "default";
      }
    }

    function finalizeSlot() {
      const count = slots.length;
      const letter = String.fromCharCode(65 + Math.floor(count / 5));
      const number = (count % 5) + 1;
      const label = `${letter}${number}`;

      slots.push({
        id: count + 1,
        points: [...tempPoints],
        label: label,
        occupied: false,
        entryTime: null,
        tempEntryTime: null, // Initialize timer property
      });

      showToast(`Slot ${label} Created`, "success");
      toggleDrawingMode();
      saveLayout();
      updateStats();
    }

    // --- UTILITIES & STORAGE ---

    function saveLayout() {
      localStorage.setItem("parkSenseLayout", JSON.stringify(slots));
    }

    function loadLayout() {
      const saved = localStorage.getItem("parkSenseLayout");
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          parsed.forEach((s) => {
            s.occupied = false;
            s.entryTime = null;
            s.tempEntryTime = null; // Reset timer on load
          });
          slots = parsed;
          updateStats();
        } catch (e) {
          console.error(e);
        }
      }
    }

    async function triggerLoadLayout() {
      const confirmed = await showConfirmModal(
        "Load layout file? Current map will be lost.",
        "Load Layout",
        "ph-upload-simple"
      );
      if (confirmed) document.getElementById("layout-loader").click();
    }

    function importLayoutFile(input) {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        try {
          const obj = JSON.parse(event.target.result);
          if (Array.isArray(obj)) {
            obj.forEach((s) => {
              s.occupied = false;
              s.entryTime = null;
              s.tempEntryTime = null; // Reset timer on import
            });
            slots = obj;
            saveLayout();
            updateStats();
            showToast(`Loaded ${slots.length} slots`, "success");
          }
        } catch (e) {
          showToast("Invalid file", "error");
        }
      };
      reader.readAsText(file);
      input.value = "";
    }

    async function exportLayout() {
      if (slots.length === 0) {
        showToast("No slots to save!", "error");
        return;
      }
      const jsonString = JSON.stringify(slots, null, 2);
      const dataStr =
        "data:text/json;charset=utf-8," + encodeURIComponent(jsonString);
      const downloadAnchorNode = document.createElement("a");
      downloadAnchorNode.setAttribute("href", dataStr);
      downloadAnchorNode.setAttribute("download", "parking_layout.json");
      document.body.appendChild(downloadAnchorNode);
      downloadAnchorNode.click();
      downloadAnchorNode.remove();
      showToast("Layout saved", "success");
    }

    async function resetMap() {
      const confirmed = await showConfirmModal(
        "Clear entire map? Irreversible.",
        "Clear Map",
        "ph-eraser"
      );
      if (confirmed) {
        slots = [];
        tempPoints = [];
        isDrawing = false;
        saveLayout();
        updateStats();
        showToast("Map Cleared", "success");
      }
    }

    function formatDuration(sec) {
      const h = Math.floor(sec / 3600)
        .toString()
        .padStart(2, "0");
      const m = Math.floor((sec % 3600) / 60)
        .toString()
        .padStart(2, "0");
      const s = (sec % 60).toString().padStart(2, "0");
      return `${h}:${m}:${s}`;
    }

    function drawOverlays() {
      slots.forEach((slot) => {
        ctx.lineWidth = 3;
        const isHovered = slot === hoveredSlot;
        const isDragging = slot === draggingSlot;

        if (slot.occupied) {
          ctx.strokeStyle = "#ef4444";
          ctx.fillStyle = "rgba(239, 68, 68, 0.25)";
        } else {
          ctx.strokeStyle = isHovered || isDragging ? "#34d399" : "#10b981";
          ctx.fillStyle =
            isHovered || isDragging
              ? "rgba(16, 185, 129, 0.3)"
              : "rgba(16, 185, 129, 0.15)";
        }

        if (isDragging) {
          ctx.lineWidth = 4;
          ctx.setLineDash([5, 5]);
        } else {
          ctx.setLineDash([]);
        }

        ctx.beginPath();
        ctx.moveTo(slot.points[0].x, slot.points[0].y);
        ctx.lineTo(slot.points[1].x, slot.points[1].y);
        ctx.lineTo(slot.points[2].x, slot.points[2].y);
        ctx.lineTo(slot.points[3].x, slot.points[3].y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]);

        const centerX = (slot.points[0].x + slot.points[2].x) / 2;
        const centerY = (slot.points[0].y + slot.points[2].y) / 2;

        ctx.fillStyle = "#fff";
        ctx.shadowColor = "rgba(0,0,0,0.8)";
        ctx.shadowBlur = 4;
        ctx.font = "bold 16px Inter";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`${slot.label}`, centerX, centerY);
        ctx.shadowBlur = 0;
        ctx.textAlign = "start";
        ctx.textBaseline = "alphabetic";
      });

      if (isDrawing && tempPoints.length > 0) {
        ctx.strokeStyle = "#f59e0b";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(tempPoints[0].x, tempPoints[0].y);
        for (let i = 1; i < tempPoints.length; i++) {
          ctx.lineTo(tempPoints[i].x, tempPoints[i].y);
        }
        ctx.stroke();

        ctx.fillStyle = "#f59e0b";
        tempPoints.forEach((p) => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
          ctx.fill();
        });
      }
    }

    function updateStats() {
      const occupied = slots.filter((s) => s.occupied).length;
      document.getElementById("total-count").innerText = slots.length;
      document.getElementById("free-count").innerText =
        slots.length - occupied;
      document.getElementById("occupied-count").innerText = occupied;
    }

    // --- DYNAMIC FEE UPDATES ---
    function calculateFee(durationSec) {
      let paymentVal = parseFloat(appConfig.baseRate);

      if (durationSec > appConfig.baseDuration) {
        const extraTime = durationSec - appConfig.baseDuration;
        const intervals = Math.ceil(extraTime / appConfig.incrementInterval);
        paymentVal += intervals * parseFloat(appConfig.incrementAmount);
      }
      return paymentVal.toFixed(2);
    }

    function updateActiveRows() {
      const now = new Date();
      slots.forEach(slot => {
        if (slot.occupied && slot.entryTime) {
          const durationSec = Math.floor((now - slot.entryTime) / 1000);
          const feeStr = calculateFee(durationSec);
          const durationStr = formatDuration(durationSec);

          const validRawTime = slot.entryTime.toISOString();
          const safeTimeId = validRawTime.replace(/[^a-zA-Z0-9]/g, '');
          const rowId = `row-${slot.label}-${safeTimeId}`;

          const row = document.getElementById(rowId);
          if (row) {
            // Columns: 0=Slot, 1=Entry, 2=Exit, 3=Duration, 4=Fee, 5=Action
            // Update Duration (index 3)
            row.cells[3].innerText = durationStr;
            row.cells[3].style.color = "var(--text-main)"; // Remove "Active" styling if we want, or keep it?
            // Actually, the plan implies checking it regularly. 
            // Let's keep the text as valid duration.

            // Update Fee (index 4)
            row.cells[4].innerText = `₱${feeStr}`;
          }
        }
      });
    }

    // Run dynamic updates every second
    setInterval(updateActiveRows, 1000);


    function addLog(msg) {
      const now = new Date();
      const timeStr = now.toLocaleTimeString("en-US", { hour12: false });
      console.log(`[ParkSense ${timeStr}] ${msg}`);
    }

    function addHistoryRow(
      slotLabel,
      entryDate,
      exitDate,
      durationStr,
      payment,
      rawEntryTime // <--- NEW PARAMETER
    ) {
      const entryStr = entryDate.toLocaleTimeString("en-PH", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: false,
      });

      const exitStr = exitDate
        ? exitDate.toLocaleTimeString("en-PH", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        })
        : "-";

      // If rawEntryTime wasn't passed (live session), use ISO
      const validRawTime = rawEntryTime || entryDate.toISOString();

      const paymentDisplay = parseFloat(payment).toFixed(2);

      // Unique ID based on slot and entry time to allow updates
      // Using a regex to make the ID safe for querySelector if needed (though getElementById is fine)
      const safeTimeId = validRawTime.replace(/[^a-zA-Z0-9]/g, '');
      const rowId = `row-${slotLabel}-${safeTimeId}`;

      const rowObj = {
        slot: slotLabel,
        entry: entryStr,
        exit: exitStr,
        duration: durationStr,
        payment: paymentDisplay,
      };
      const dataString = JSON.stringify(rowObj).replace(/"/g, "&quot;");

      // Check if this row already exists
      let tr = document.getElementById(rowId);
      const isNew = !tr;

      if (!tr) {
        tr = document.createElement("tr");
        tr.id = rowId;
      }

      const durationDisplay = exitDate
        ? durationStr
        : `<span style="color: var(--warning); font-weight: bold; animation: pulse 2s infinite;">Active</span>`;

      tr.innerHTML = `
            <td class="font-mono" style="font-weight: 700; color: var(--primary)">${slotLabel}</td>
            <td class="font-mono">${entryStr}</td>
            <td class="font-mono">${exitStr}</td>
            <td>${durationDisplay}</td>
            <td class="font-mono" style="color:var(--success);">₱${paymentDisplay}</td>
            <td>
                <div class="action-cell" style="justify-content: flex-end">
                    <button class="icon-btn" onclick="openSpecificTicket(${dataString})" title="View Ticket"><i class="ph-bold ph-receipt"></i></button>
                    <!-- Pass the validRawTime to delete function -->
                    <button class="icon-btn delete" onclick="deleteHistoryRow(this, '${slotLabel}', '${validRawTime}')" title="Delete"><i class="ph-bold ph-trash"></i></button>
                </div>
            </td>`;

      if (isNew) {
        historyBody.prepend(tr);
      }
    }

    async function deleteHistoryRow(button, slot, entryTime) {
      const confirmed = await showConfirmModal(
        `Delete record for Slot ${slot}?`,
        "Delete Record",
        "ph-trash"
      );
      if (!confirmed) return;

      // --- START LOCALSTORAGE DELETE LOGIC ---
      try {
        const existingHistory = JSON.parse(localStorage.getItem('parkingHistory') || '[]');
        // Filter out the record matching slot AND entryTime (or ID if available)
        // Using entry_time as unique identifier since we have it
        const newHistory = existingHistory.filter(item => {
          // Check against both conventions just in case
          const itemEntry = item.entry_time || item.entry;
          return !(item.slot === slot && itemEntry === entryTime);
        });

        localStorage.setItem('parkingHistory', JSON.stringify(newHistory));
        showToast("Record Deleted", "success");
      } catch (error) {
        console.error(error);
        showToast("Delete Error", "error");
        return;
      }
      // --- END LOCALSTORAGE DELETE LOGIC ---

      // UI Updates (Only runs if DB delete was successful)
      const amountText = button
        .closest("tr")
        .children[4].innerText.replace("₱", "");
      const amount = parseFloat(amountText);
      if (!isNaN(amount)) {
        revenueTotal -= amount;
        document.getElementById("total-revenue").innerText =
          revenueTotal.toFixed(2);
      }

      button.closest("tr").remove();

      // Remove from Revenue table as well
      // Note: This matches based on the exact string passed to dataset
      // If formats differ slightly between history and revenue, this might miss,
      // but generally works if passed consistently.
      const revRows = document.querySelectorAll("#revenue-body tr");
      revRows.forEach((r) => {
        // Simple check, or strict check if you add dataset attributes to rows
        if (r.innerText.includes(slot) && r.innerText.includes(amountText)) {
          r.remove();
        }
      });
    }

    function addRevenueRow(slot, payment, isoEntryTime) {
      revenueTotal += parseFloat(payment);
      totalRevenueEl.innerText = revenueTotal.toFixed(2);
      transactionCount++;

      const tr = document.createElement("tr");
      tr.dataset.slot = slot;
      tr.dataset.entry = isoEntryTime;
      tr.innerHTML = `
        <td class="font-mono" style="color:var(--text-muted)">#${transactionCount
          .toString()
          .padStart(4, "0")}</td>
        <td class="font-mono"><strong>${slot}</strong></td>
        <td class="font-mono" style="color:var(--success)">₱${parseFloat(
            payment
          ).toFixed(2)}</td>
        `;
      revenueBody.prepend(tr);
    }

    function openGraphs() {
      localStorage.setItem("allHistory", JSON.stringify(historyData));
      localStorage.setItem("allRevenue", JSON.stringify(revenueData));
      window.location.href = "graphs.html";
    }

    async function loadExistingData() {
      try {
        // Load from LocalStorage instead of API
        const rawData = localStorage.getItem('parkingHistory');
        const data = rawData ? JSON.parse(rawData) : [];

        // Clear current tables
        historyBody.innerHTML = "";
        revenueBody.innerHTML = "";
        revenueTotal = 0;
        transactionCount = 0;

        // If no data
        if (!Array.isArray(data)) {
          console.log("No data found or invalid format");
          return;
        }

        // Sort by entry time descending (newest first)
        data.sort((a, b) => {
          const timeA = new Date(a.entry_time || a.entry).getTime();
          const timeB = new Date(b.entry_time || b.entry).getTime();
          return timeB - timeA;
        });

        // Process the data from DB
        data.forEach((entry) => {
          // PHP sends Date strings (e.g., "2023-11-24 10:00:00")
          // We need to convert them to JS Date objects for formatting
          const entryTime = new Date(entry.entry_time);
          const exitTime = new Date(entry.exit_time);

          const durationSec = parseInt(entry.duration_sec);
          const durationStr = formatDuration(durationSec);
          const paymentFixed = parseFloat(entry.payment).toFixed(2);

          // ISO string is needed for the Delete logic later
          // Note: entry.entry_time from PHP is usually sufficient,
          // but we ensure consistency here.
          const isoEntry = entry.entry_time;

          // Add to UI
          addHistoryRow(
            entry.slot,
            entryTime,
            exitTime,
            durationStr,
            paymentFixed,
            isoEntry // Pass the raw DB string for deletion accuracy
          );

          addRevenueRow(entry.slot, paymentFixed, isoEntry);
        });

        // Update Total Revenue UI
        document.getElementById("total-revenue").innerText =
          revenueTotal.toFixed(2);
      } catch (error) {
        console.error("Error loading data:", error);
        showToast("Failed to connect to Database", "error");
      }
    }

    // Initialize
    startCamera();
    loadLayout();
    loadExistingData();
  </script>
</body>

</html>